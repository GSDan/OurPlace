#region copyright
/*
    OurPlace is a mobile learning platform, designed to support communities
    in creating and sharing interactive learning activities about the places they care most about.
    https://github.com/GSDan/OurPlace
    Copyright (C) 2018 Dan Richardson

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see https://www.gnu.org/licenses.
*/
#endregion

// This file has been autogenerated from a class added in the UI designer.

using System;
using System.Drawing;
using System.IO;
using System.Threading.Tasks;
using FFImageLoading;
using FFImageLoading.Transformations;
using Foundation;
using MobileCoreServices;
using OurPlace.Common.Models;
using OurPlace.iOS.Controllers.Create;
using UIKit;

namespace OurPlace.iOS
{
    // https://ilovemyapps.wordpress.com/2010/05/12/monotouch-tip-3-moving-the-view/
    public partial class Create_ActivityMetaController : Create_BaseSegueController
    {
        private float scrollamount = 0.0f;
        private float bottomPoint = 0.0f;
        private bool moveViewUp = false;
        private UITextField lastEdit;
        private UIImagePickerController imagePicker;
        private UIDocumentPickerViewController docPicker;
        private string folderPath;
        private string previousImagePath;
        private string currentImagePath;

        public Create_ActivityMetaController(IntPtr handle) : base(handle)
        {
        }

        protected AppDelegate ThisApp
        {
            get { return (AppDelegate)UIApplication.SharedApplication.Delegate; }
        }

        public override void TouchesBegan(NSSet touches, UIEvent evt)
        {
            ActivityTitle.ResignFirstResponder();
            ActivityDescription.ResignFirstResponder();
            ResetTheView();
        }

        public override void ViewDidLoad()
        {
            base.ViewDidLoad();

            NSNotificationCenter.DefaultCenter.AddObserver(UIKeyboard.DidShowNotification, KeyboardUpNotification);

            ActivityTitle.ShouldReturn += TextFieldShouldReturn;
            ActivityTitle.EditingDidBegin += TextFieldEditingDidBegin;
            ActivityDescription.ShouldReturn += TextFieldShouldReturn;
            ActivityDescription.EditingDidBegin += TextFieldEditingDidBegin;

            // Limit how long the title and description strings can be
            ActivityTitle.ShouldChangeCharacters += (textField, range, replacementString) =>
            {
                var newLength = textField.Text.Length + replacementString.Length - range.Length;
                return newLength <= 36 || (replacementString.Length - range.Length <= 0);
            };

            ActivityDescription.ShouldChangeCharacters += (textField, range, replacementString) =>
            {
                var newLength = textField.Text.Length + replacementString.Length - range.Length;
                return newLength <= 128 || (replacementString.Length - range.Length <= 0);
            };

            UITapGestureRecognizer tapGestureRecognizer =
                new UITapGestureRecognizer(() => View.EndEditing(true));
            View.AddGestureRecognizer(tapGestureRecognizer);

            UITapGestureRecognizer imageTapGesture = new UITapGestureRecognizer(ImageTapped)
            {
                NumberOfTapsRequired = 1
            };
            ActivityLogo.UserInteractionEnabled = true;
            ActivityLogo.AddGestureRecognizer(imageTapGesture);

            folderPath = Common.LocalData.Storage.GetCacheFolder("created");

            if (thisActivity != null)
            {
                // Load previously entered data into fields
                ActivityTitle.Text = thisActivity.Name;
                ActivityDescription.Text = thisActivity.Description;
                if (!string.IsNullOrWhiteSpace(thisActivity.ImageUrl))
                {
                    previousImagePath = thisActivity.ImageUrl;
                    Console.WriteLine("Existing image path: " + previousImagePath);

                    string url = AppUtils.GetPathForLocalFile(previousImagePath);

                    var suppress = ImageService.Instance.InvalidateCacheEntryAsync(url, FFImageLoading.Cache.CacheType.All, true);
                    ImageService.Instance.LoadFile(url).Transform(new CircleTransformation()).Into(ActivityLogo);
                }
            }

            ContinueButton.TouchUpInside += ContinuePressed;
            CancelButton.TouchUpInside += CancelPressed;
        }

        private void ImageTapped()
        {
            UIAlertController alert = UIAlertController.Create("Choose Image Source", null, UIAlertControllerStyle.ActionSheet);
            alert.AddAction(UIAlertAction.Create("Camera", UIAlertActionStyle.Default, (a) => { OpenCamera(); }));
            alert.AddAction(UIAlertAction.Create("Gallery", UIAlertActionStyle.Default, (a) => { OpenImagePicker(); }));
            alert.AddAction(UIAlertAction.Create("Other Sources", UIAlertActionStyle.Default, (a) => { OpenDocumentPicker(); }));
            alert.AddAction(UIAlertAction.Create("Cancel", UIAlertActionStyle.Cancel, null));

            // On iPad, it's a pop up. Make it appear below the image
            UIPopoverPresentationController popCont = alert.PopoverPresentationController;
            if (popCont != null)
            {
                popCont.SourceView = ActivityLogo;
                popCont.SourceRect = ActivityLogo.Bounds;
                popCont.PermittedArrowDirections = UIPopoverArrowDirection.Up;
            }

            PresentViewController(alert, true, null);
        }

        private void OpenCamera()
        {
            imagePicker = new UIImagePickerController
            {
                SourceType = UIImagePickerControllerSourceType.Camera,
                MediaTypes = new string[] { UTType.Image }
            };
            imagePicker.FinishedPickingMedia += ImagePicker_FinishedPickingMedia;
            imagePicker.Canceled += (object sender, EventArgs e) => { imagePicker.DismissViewController(true, null); };
            PresentViewController(imagePicker, true, null);
        }

        // https://github.com/xamarin/recipes/tree/master/Recipes/ios/media/video_and_photos/choose_a_photo_from_the_gallery
        private void OpenImagePicker()
        {
            imagePicker = new UIImagePickerController
            {
                SourceType = UIImagePickerControllerSourceType.PhotoLibrary,
                MediaTypes = new string[] { UTType.Image }
            };
            imagePicker.FinishedPickingMedia += ImagePicker_FinishedPickingMedia;
            imagePicker.Canceled += (object sender, EventArgs e) => { imagePicker.DismissViewController(true, null); };
            PresentViewController(imagePicker, true, null);
        }

        private void ImagePicker_FinishedPickingMedia(object sender, UIImagePickerMediaPickedEventArgs e)
        {
            bool isImage = false;
            switch (e.Info[UIImagePickerController.MediaType].ToString())
            {
                case "public.image":
                    Console.WriteLine("Image selected");
                    isImage = true;
                    break;
                case "public.video":
                    Console.WriteLine("Video selected");
                    break;
            }

            if (!isImage) return; //sanity check against video

            NSUrl referenceUrl = e.Info[new NSString("UIImagePickerControllerReferenceURL")] as NSUrl;
            UIImage passedImage = e.Info[UIImagePickerController.OriginalImage] as UIImage;

            ShrinkAndSaveNewImage(passedImage);

            imagePicker?.DismissViewController(true, null);
        }


        private void ShrinkAndSaveNewImage(UIImage passedImage)
        {
            if (passedImage == null) return;

            UIImage smallerImage = AppUtils.ScaleAndRotateImage(passedImage, 800);
            NSData imageData = smallerImage.AsJPEG(0.8f);

            if (currentImagePath == null)
            {
                currentImagePath = Path.Combine(folderPath, "icon_" + DateTime.UtcNow.ToString("s") + ".jpg");
            }
            else if (!File.Exists(currentImagePath))
            {
                File.Create(currentImagePath);
            }

            // save the image data to a folder ready for uploading
            if (imageData.Save(currentImagePath, true))
            {
                Console.WriteLine("Saved photo to: " + currentImagePath);
                ImageService.Instance.InvalidateCacheEntryAsync(currentImagePath, FFImageLoading.Cache.CacheType.All, true);
                ImageService.Instance.LoadFile(currentImagePath).Transform(new CircleTransformation()).Into(ActivityLogo);
            }
            else
            {
                Console.WriteLine("ERROR saving to " + currentImagePath);
            }
        }

        private async Task OpenDocumentPicker()
        {
            if (PresentedViewController != null)
            {
                await DismissViewControllerAsync(false);
            }

            // Allow the Document picker to select a range of document types
            var allowedUTIs = new string[] {
                UTType.PNG,
                UTType.JPEG,
                UTType.Image
            };

            // Display the picker
            docPicker = new UIDocumentPickerViewController(allowedUTIs, UIDocumentPickerMode.Import);
            docPicker.AllowsMultipleSelection = false;
            docPicker.DidPickDocumentAtUrls += DocPicker_DidPickDocumentAtUrls;

            await PresentViewControllerAsync(docPicker, false);
        }

        void DocPicker_DidPickDocumentAtUrls(object sender, UIDocumentPickedAtUrlsEventArgs e)
        {
            if (e.Urls == null || e.Urls.Length < 1) return;

            docPicker?.DismissViewControllerAsync(true);

            // IMPORTANT! You must lock the security scope before you can
            // access this file
            var securityEnabled = e.Urls[0].StartAccessingSecurityScopedResource();

            ThisApp.ClearDocumentHandler();
            ThisApp.DocumentLoaded += ThisApp_DocumentLoaded;
            ThisApp.OpenDocument(e.Urls[0]);

            // IMPORTANT! You must release the security lock established
            // above.
            e.Urls[0].StopAccessingSecurityScopedResource();
        }

        public void ThisApp_DocumentLoaded(Helpers.GenericTextDocument document)
        {
            if (currentImagePath != null && currentImagePath != previousImagePath)
            {
                File.Delete(AppUtils.GetPathForLocalFile(currentImagePath));
            }

            string tempPath = document.FileUrl.Path;

            UIImage fullSize = UIImage.FromFile(tempPath);

            ShrinkAndSaveNewImage(fullSize);
        }

        private bool TextFieldShouldReturn(UITextField tf)
        {
            tf.ResignFirstResponder();
            if (moveViewUp) { ScrollTheView(false); }
            return true;
        }

        private void TextFieldEditingDidBegin(object sender, EventArgs e)
        {
            lastEdit = (UIKit.UITextField)sender;
        }


        private void KeyboardUpNotification(NSNotification notification)
        {
            ResetTheView();

            RectangleF r = (System.Drawing.RectangleF)UIKeyboard.BoundsFromNotification(notification);


            if (lastEdit != null && lastEdit.IsEditing)
            {
                //Calculate the bottom of the Texbox
                //plus a small margin...
                bottomPoint = ((float)(lastEdit.Frame.Y + lastEdit.Frame.Height + 20));

                //Calculate the amount to scroll the view
                //upwards so the Textbox becomes visible...
                //This is the height of the Keyboard -
                //(the height of the display - the bottom
                //of the Texbox)... 
                scrollamount = ((float)(r.Height - (View.Frame.Size.Height - bottomPoint)));
            }

            //Check to see whether the view
            //should be moved up...
            if (scrollamount > 0)
            {
                moveViewUp = true;
                ScrollTheView(moveViewUp);
            }
            else moveViewUp = false;
        }

        private void ResetTheView()
        {
            UIView.BeginAnimations(string.Empty, System.IntPtr.Zero);
            UIView.SetAnimationDuration(0.3);

            RectangleF frame = (System.Drawing.RectangleF)View.Frame;
            frame.Y = 0;
            View.Frame = frame;
            UIView.CommitAnimations();
        }

        private void ScrollTheView(bool movedUp)
        {
            //To invoke a views built-in animation behaviour,
            //you create an animation block and
            //set the duration of the move...∂
            //Set the display scroll animation and duration...
            UIView.BeginAnimations(string.Empty, System.IntPtr.Zero);
            UIView.SetAnimationDuration(0.15);

            //Get Display size...
            RectangleF frame = (System.Drawing.RectangleF)View.Frame;

            if (movedUp)
            {
                //If the view should be moved up,
                //subtract the keyboard height from the display...
                frame.Y -= scrollamount;
            }
            else
            {
                //If the view shouldn't be moved up, restore it
                //by adding the keyboard height back to the original...
                frame.Y += scrollamount;
            }

            //Assign the new frame to the view...
            View.Frame = frame;

            //Tell the view that your all done with setting
            //the animation parameters, and it should
            //start the animation...
            UIView.CommitAnimations();

        }

        private void ContinuePressed(object sender, EventArgs e)
        {
            if (string.IsNullOrWhiteSpace(ActivityTitle.Text))
            {
                AppUtils.ShowSimpleDialog(this, "Missing Title", "Please enter a title for your Activity!", "Got it");
                return;
            }

            if (string.IsNullOrWhiteSpace(ActivityDescription.Text))
            {
                AppUtils.ShowSimpleDialog(this, "Missing Description", "Please enter a short description describing what your Activity is about!", "Got it");
                return;
            }

            if (thisActivity == null)
            {
                thisActivity = new LearningActivity
                {
                    Id = (new Random()).Next()
                };
            }

            thisActivity.ImageUrl = currentImagePath;
            thisActivity.Name = ActivityTitle.Text;
            thisActivity.Description = ActivityDescription.Text;

            if (!string.IsNullOrWhiteSpace(currentImagePath))
            {
                thisActivity.ImageUrl = Path.Combine(Directory.GetParent(currentImagePath).Name, Path.GetFileName(currentImagePath));

                if (!string.IsNullOrWhiteSpace(previousImagePath))
                {
                    // new image replaces old one, delete the previous image
                    File.Delete(AppUtils.GetPathForLocalFile(previousImagePath));
                }
            }

            PerformSegue("UnwindToOverview", this);
        }

        private void CancelPressed(object sender, EventArgs e)
        {
            wasCancelled = true;
            PerformSegue("UnwindToOverview", this);
        }

    }
}
